---
title: Simulating Coin Flip
author: geshun
date: '2019-08-05'
slug: simulating-coin-flip
categories:
  - R
tags:
  - probability
  - bimonial
output: 
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: tango
---

Simulation is one of the statistical methods for looking at the best decision to make given a scenario. The underlying idea is that, if we can playout the scenario a lot of times, we can know the expected outcome of the scenario.

## Required Packages

```{r load_packages, message=FALSE}
library(tidyverse)
```

## Flipping a Coin

Suppose you flip a fair coin ten times, whatâ€™s the most likely number of head? Since heads and tails are equally likely, you might say 5 will be heads and 5 will be tail. Suppose we bet that I give you a dollar if you guessed right and you give me a dollar otherwise. Do you have to take the bet?

Under the assumption that the coin is fair and thus, head and tail are equally likely, we can say that the outcome is either 1 for head or 0 for tail and represent the set of possible outcome of throwing a fair coin as `c(0, 1)`. The `sample()` function from the base package can be used to select either a head or tail with replacement, thus `x <- sample(c(0, 1), 10, replace =  TRUE)`. Taking `sum(x)` will give us the number of heads. Let's wrap that in a function. 

```{r}
toss_coin_n_times <- function(n = 10) {
  x <- sample(c(0, 1), n, replace = TRUE)
  sum(x)
}

set.seed(1)
toss_coin_n_times()
# 4

set.seed(1234)
toss_coin_n_times()
# 6
```

To get closer to the true probability of the outcome of tossing a fair coin 10 times, we need to repeat this experiment dozen times. Since the claim is that there will be 5 heads and 5 tails, we will find the proportion of times we get 5 heads. As a starter, we will run our `toss_coin_n_times` function 100 times. Once again, let's wrap our loop in a function. We will use the idea that `mean` of a vector with `TRUE` or `FALSE` elements is the proportion of true(s) in the vector. Note that `mean` coerces `TRUE` to `1` and `FALSE` to `0`.

```{r}
repeat_m_times <- function(f, m = 100, heads = 5) {
  outcome <- numeric(length = m)
  for (i in 1:m) {
    outcome[i] <- f()
  }
  list(proportion = mean(outcome == heads), 
       outcomes = outcome)
}

set.seed(1)
repeat_m_times(toss_coin_n_times)$proportion
# 0.26 (26% of the time we get heads)

set.seed(1234)
repeat_m_times(toss_coin_n_times)$proportion
# 0.24 (24% of the time we get heads)

# let's run it 1 million times
result <- repeat_m_times(toss_coin_n_times, m = 1e4)
result$proportion
# around 24% all the time

hist(result$outcomes)
```

We can say that we have about 24% chance of getting 5 heads out of throwing a fair coin 10 times. This is not what we expected. Note: We need to visualize the distribution of our coin toss with a histogram.

R often provides ways of escape when using `for` loops. The loop could have been replaced with the `replicate()` function from the base package. We can achieve the same result with `replicate(100, toss_coin_n_times())`. The `sapply` function from the apply family can also be useful in this case `sapply(rep(10, 100), toss_coin_n_times)`. You guessed right if you thought of `map_dbl` from the purrr package. Which we can use in this way: `map_dbl(1:100, ~toss_coin_n_times(10))`. 

In functional programming terms, the purrr package offers us more flexibility. The strength of R is in it numerous packages and thanks to Hadley Wilkam for the purrr package. Our `toss_coin_n_times()` function could be written with purrr flavor. 

```{r}
toss_n_times <- compose(sum, 
                        partial(sample, x = c(0, 1), replace = TRUE))
result <- map_dbl(1:100, ~toss_n_times(10)) 
mean(result == 5)
```
Which of the implimentation is fast? We could also do parallel programming here since our problem can be classified as embarassingly parallel. 

Our coin toss bet could have been modeled using Binomial distribution. At each toss of the coin, the outcome of one does not influence the other, hence independent outcomes. The `rbinom()` function from the stats package will be useful in this case. Instead of flipping one coin 10 times, we can capture the notion of replicating this single coin flipped 10 times by considering say 100 coins each flipped 10 times. Here, the `repeat_m_times` is the same as m-number of coins. 

```{r}
result <- rbinom(100, 10, 0.5)
mean(result == 5)
```
Re-thinking the problem in the context of Binomial distribution allows us to utilize a lower level function (written in C) that is supper fast not only that its rigorous and simple to impliment with few lines of code. We can also talk about the notion of bais coin by just altering the probability to be not equal to `0.5`.

## Density

We want to know the number of heads after 10 flips of a fair coin, thus our random variable. The outcome of each flip or trial is independent of the outcome of the other. Also, each outcome is dichotomous, thus either head or tail, yes or no, success or failure. Again, the number of trails is fixed. In our case 10 flips. And finally, the probability of success or getting a head is fixed for each trial. The above is what makes our random variable a Binomial random variable.

We find the probability a Binomial random variable $X \sim Binomial(10, 0.5)$, with 10 coins, each with a 50% probability-results in an outcome of 5, $Pr(X = 5)$. Flipping a single fair coin 10 times is same as flipping 10 fair coins once. Now, our task is to answer, what is the probability that the outcome results in 5 heads? One way to find out is to simulate many draws from the Binomial distribution `X` above and see how common each outcome is.

The `rbinom` function does that for us. If we want to simulate say 1e6 times, we do `flips <- rbinom(1e6, 10, 0.5)`. We plot `flips` as histogram to see the relative frequency of each possible outcome $\{0, 1, 2, ..., 10\}$. That is, out of the 10 flips (of a single coin) or 10 coins (of a single flip), we can have no heads, 1 head, 2 heads, ..., 10 heads.

```{r}
flips <- rbinom(1e6, 10, 0.5)
qplot(flips, 
      geom = 'histogram', 
      fill = I("blue"), 
      xlab = "outcome", 
      ylab = "frequency", 
      alpha = I(.4))
mean(flips == 5)
```

There are about 24.6% chance of getting 5 heads out of 10 flips. This (24.6%) is called the density of the binomial at point 5. R provides the `dbinom` function which estimates the exact density of an outcome. `dbinom` takes 3 arguments, the outcome we are estimating the density at (which is 5), the number of coins (which is 10) and the probability of each being heads (which is 0.5); `dbinom(5, 10, 0.5)`. This confirms the result from our simulation, that the probability is about 24.6%.

The analytical approach formulae is $\binom{n}{k}p^k(1-p)^{(n-k)} \rightarrow \binom{10}{5}0.5^5(1-0.5)^{(10-5)}\rightarrow 0.246$